%
\documentclass[conference]{IEEEtran}
\usepackage{times}

% numbers option provides compact numerical references in the text. 
\usepackage[numbers]{natbib}
\usepackage{multicol}
\usepackage[bookmarks=true]{hyperref}
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsmath}

%% Tarik's Shortcuts
% For marking TODOs in an obvious way
\newcommand{\TODO}[1]{ {\bf \textcolor{red}{TODO:} #1 }}
\usepackage{amsbsy}

\begin{document}

% paper title
\title{Computer-aided design of complex configurations and behaviors for modular robots}

% You will get a Paper-ID when submitting a pdf file to the conference system
\author{Author Names Omitted for Anonymous Review. Paper-ID [add your ID here]}

\maketitle

\begin{abstract}
In this paper, we present a scalable software framework for the design of modular robot configurations and behaviors. Designs are constructed hierarchically by composing elements from a library, allowing users to easily create complex designs.  Likewise, complex behaviors are constructed by composing controllers from a library in a nested series/parallel structure. The system is integrated with a full dynamic simulator, and provides tools to identify common problems with behaviors, specifically self-collision and loss of quasi-static stability.

\end{abstract}

\section{Introduction}
Modular reconfigurable robot systems have been studied extensively for several decades \TODO{citations}.  These systems distinguish themselves in their ability to transform into different shapes to address a wide variety of tasks.

This additional flexibility places an additional burden on the user, because solving problems with modular robots involves not only designing  software,
but also the best physical form for the task at hand. We argue that if this
complexity is not appropriately managed, it can make the system
impractical.  If the user is free to create any new design  he/she pleases to
solve a new task, but must program the design from scratch every time, creating
new designs will be a huge amount of effort, and the advantage of flexible modular
hardware will be defeated.

Software modularity is a well-established practice for developing large
maintainable systems and avoiding duplication of effort \TODO{cite}.  In robotics, software
behaviors are inextricably linked to the hardware they control, resulting in
additional challenges to modularity.  Significant progress has been made in
sharing robotics software between researchers
 and hardware platforms, most notably
 ROS which provides IPC and standard libraries for common robot tasks. 

The challenges of software design are different in modular robotics than
in typical robotics, because the hardware itself is modular. Porting software
from one robot platform to a completely different robot platform takes a
considerable amount of time, and needs to be facilitated by a large framework
such as ROS, in which fundamental software libraries are almost totally decoupled from
specific hardware.  In modular robotics, the emphasis needs to be on speed of
design, because the major advantage of a modular robot system is that new
designs can be made for each task.  We need to  very quickly develop simple kinematic
behaviors (\textit{i.e.} take a step with a leg) with new morphologies that share some of the
structure of old morphologies.

Our solution to this problem is to let the modularity of our hardware determine the
modularity of our software.  We create new modular robot designs by combining existing sub-designs,
for example combining four legs with a body to create a walking robot.
 We provide a GUI tool that allows users to do this easily.  Designs have
associated libraries of software behaviors, so that when new designs  are created
by composing existing sub-designs,  new behaviors for that design can be quickly
and easily created by composing the behaviors associate with its component
sub-designs.  We introduce new scripting language with a series-parallel
execution structure that allows old behaviors to be easily and clearly combined
into new behaviors.

Since combining old things in new ways can lead to unexpected problems, we also
need to verify that our new designs and behaviors perform the way we expect them
to.  This is done in a dynamic simulation in Gazebo, and through
verification tools that detect common problems.


\section{Contribution and Paper Structure}

The primary contribution of this paper is a software framework that allows modular
robot configurations and behaviors to be built hierarchically, and a simulation
environment that helps the user verify intended behavior.  Together, these tools
help manage the complexity of a modular robot system, significantly reducing the
time and effort required to accomplish tasks with modular robots.

The software we developed is open-source and freely available at\TODO{Link}.  Our
code is built for SMORES,  a modular robot developed at the University of
Pennsylvania (see sec \ref{fig:SmoresRobot}), but could easily be adapted for use with
other modular robot systems.

The remainder of this paper provides a comprehensive description of the
structure and algorithmic components of our software system.  In Section \ref{sec:related-work},
we discuss relevant background material.
In Section \ref{sec:preliminaries} we introduce terminology and  concepts used elsewhere in the
paper. 
In Section \ref{sec:approach}, we describe the algorithmic basis
for the three major components of our framework - design composition, behavior
composition, and behavior verification.  In Section
\ref{sec:example}, we discuss the open-source software
tools used to implement our system, and provide examples demonstrating a user'¿s
workflow when using this system.  We demonstrate that our framework saves the
user time and effort, and allows him or her to easily develop complex and
capable designs.


\section{Related Work}
\label{sec:related-work}
In some respect, our work parallels the efforts of Mehta \cite{mehta2014design}
and Bezzo \cite{bezzo2014demo}, who aim to create and program printable robots from
design specification by a novice user.  Users create new designs by composing
existing elements from a design library, and appropriate circuitry and
control software are automatically generated as physical designs are assembled. The framework we present is
intended specifically for modular robots, and consequently the workflow and design considerations are fundamentally different
from that presented by Mehta and Bezzo.  In
traditional robot design (or printable robot design), hardware and software are somewhat
decoupled - hardware is
designed and built once, and then programmed many times.  In the case of a MRS, the system can be reconfigured to meet new tasks,
so hardware configuration and behavior programming go hand in hand.  We intend
our system to be fast enough that the user could conceivably develop and program
a new design for every new task - designs are built once, and programmed once.  Where Mehta et al provide many facilities to generate and verify
low-level behaviors (i.e. motor drivers appropriate for motors, we do so for
high-level behaviors.

A significant amount of work has been done in developing behaviors and software
for modular robots.  Much of this work focused on automatically
generating  designs and behaviors using artificial intelligence systems.   Genetic
algorithms have been applied for the automated generation of designs
and behaviors \cite{hornby2003generative}.  Other work has
focused on emergent behavior from distributed algorithms \TODO{cite papers}.

While significant progress has been made in the automated generation of modular robot behaviors,
automated systems are not yet capable of making modular robots truly useful in practice
\cite{yim2007modular}.  The need for new programming techniques to manage the complexity
of modular robot systems has been acknowledged in the literature \cite{yim2000modular}.
Historically, gait tables have been a commonly used format in which open-loop kinematic
behaviors can be easily encoded \cite{yim1994locomotion}. Phased automata have also
been presented as a way to easily create scalable gaits for large numbers of modular
robots \cite{zhang2003phase}. In this paper, we present a novel scripting language
to quickly create complex behaviors for modular robots.

Our framework assists users in verifying design validity by identifying self-collision
and loss of gravitational stability. Identification of these conditions is common
in modular robot reconfiguration planning \cite{casal2001reconfiguration} and motion
planning \cite{yoshida2002self}.

\section{Preliminaries}
\label{sec:preliminaries}
\subsection{SMORES robot}
We have developed our system for the SMORES modular robot, developed at the
University of Pennsylvania \cite{Davey2012}. Each SMORES modules has four DoF
(DoF) - three continuously rotating faces we call {\em turntables} and one
central hinge with a $180^o$ range of motion (Figure~\ref{fig:SmoresRobot}). The
DoF marked 1, 2, and 4 have rotational axes that are parallel and coincident.
SMORES modules may connect to one another via magnets on each of their four
faces, and are capable of  self-reconfiguration.

Note that while we demonstrate our software with SMORES, it is not limited to the SMORES robot - it could be applied to any modular robot which may be simulated using Gazebo.


\begin{figure}[tb]
    \begin{center}
        \includegraphics[width=\columnwidth]{images/smores_robot.png}
    \end{center}
    \caption{SMORES robot}
    \label{fig:SmoresRobot}
\end{figure}

\subsection{Concepts and terms}

A \textit{configuration} is a contiguous set of connected modules which we treat as a
single robot.  Configurations are defined by their connective structure, and
are represented by graphs with nodes representing modules and edges
representing connections between modules.  Edges are labeled to indicate which
faces are connected as well as any angular offset, so that all information
about the connective topology of the modules is captured.  Individual modules
are considered interchangeable (as long as they are of the same kind), so any
two identically connected sets of modules are considered instances of the same
configuration.

A \textit{behavior} is a programmed sequence of movements for a specific configuration
intended to produce a desired effect.  A gait for walking is one example.  In
this paper, we consider open-loop kinematic behaviors represented as
series-parallel action graphs, described in detail in section
\ref{sec:behavior-representation}.

A \textit{controller} is a position and velocity servo for one DoF of a modular
robot.  A controller takes as input a desired position or angular velocity, and
drives the error between the desired and actual state of the DoF it controls to
zero over time.

When writing a behavior, it is possible to command one controller to
simultaneously hold more than one desired position; this is known as a
\textit{controller conflict}.  Behaviors with controller conflicts are
impossible to execute.

During execution of a behavior, a \textit{self-collision} can occur when two
different parts of configuration are commanded to occupy the same location in
space.  Self-collisions can damage the robot, and are usually unwanted.

While executing many behaviors, it is desirable to maintain \textit{gravitational
stability} (also called quasi-static stability).  Informally speaking, a
robot is gravitationally stable when it is balanced, and gravity does not
create any net moment on it.  Mathematically, the robot is gravitationally stable
if the Z-projection of its center of
mass lies within the convex hull of its load-supporting contact points in the
ground plane.  

\section{Approach and Algorithm}
\label{sec:approach}
\TODO{Tarik and Jim write (see subsections)}
\paragraph{Configuration composition}
Define the composition of a set of configurations to a single configuration.

\subsection{Configuration Composition}
\TODO{Jim writes}
\paragraph{Input}
A set of configurations. A topology graph representing the connectivity among those configurations. A base module (for position transformation).
\paragraph{Output}
A composed configuration if it is safe.
\paragraph{Procedure}
\begin{itemize}
\item Start from the configurations that connects to the configuration with base module, transform their positions based on the position of the base configuration and topology graph.
\item Check if there is any collisions among the modules and report such collision.
\item \textbf{Check if the final configuration is stable. If not, find the plane that will make the configuration stable and transform the configuration.}
\item Show the expected behavior in simulator.
\end{itemize}

\paragraph{Controller composition}
Define the composition of a set of controllers to a single controller. Define the difference between a parallel composition and a series composition. Define the control composition graph.

\subsection{Behavior Representation: Series-Parallel Action Graphs}
\label{sec:behavior-representation}
We present a novel motion description language for modular robots.  The
language aims to balance simplicity and expressiveness, and is compositional in
nature, designed to manage the complexity of developing complicated behaviors
for large clusters of modular robots through abstraction and modularity.

The fundamental atoms of the language are called actions.  An \textit{action} is a tuple \(
(J, X, \xi, T)\), where \(J\) identifies a single DoF of a configuration, X is a
controller setpoint for that degree of freedom, \(\xi\) specifies an interrupt
condition, and T specifies a timeout.  Basically, an action defines a setpoint
(position or velocity) that the controller will maintain until either the
interrupt condition is met or time runs out, whichever comes first.  The
interrupt condition can be set to \(FALSE\) (so that only the timeout has effect),
and \(T\) can be set to infinity (so that only the interrupt has effect).  This is
similar to typical atomic elements of an MDLe (see \cite{hristu2003motion}) except that our
atoms specify controller setpoints for a single DoF, rather than the entire
robot.  This is because our language includes two fundamental composition operators,
\(P_c\) (parallel) and \(S_c\) (series), to build behaviors by composing sub-behaviors.

We define a \textit{behavior} as a directed acyclic graph where nodes are actions and
edges are transitions between actions.  A behavior \(B\) always has two
special nodes \(S\) and \(T\), which are the \textit{Start} and \textit{Termination} nodes, respectively.
The smallest behavior consists of \(S\), \(T\), and a single action.  Behavior execution follows three simple rules:

\begin{enumerate}
\item Execution begins at \(S\).  \(S\) completes immediately.
\item Each action begins execution upon completion of \textit{all} is parent actions.
\item All sequences of execution end at \(T\).
\end{enumerate}

Because execution begins at \(S\) and ends at \(T\), there must be a
(directed) path from every \(S\) to every node in \(B\), and also from every node in \(B\)
to \(T\).  \(B\) is therefore a \textit{directed series-parallel graph} (SPG). SPG's
can always be formed recursively by parallel and series composition operations \cite{SPG}. The
parallel composition \(P\) of two behaviors \(B_1\), \(B_2\), \(P = Pc(B_1, B_2)\)
is the disjoint
union of their nodes (actions), merging \(S_1\) with \(S_2\) and \(T_1\) with \(T_2\). The series
composition of \(B_1\), \(B_2\), \(S = Sc(B_1, B_2)\) is created from their disjoint union by
merging \(T_1\) and \(S_2\), so that \(B_1\) and \(B_2\) execute sequentially\footnote{Since
the merged node is not an action, we can freely omit it and instead draw edges
from each of its parent nodes to each of its child nodes.}.  Note that if \(B_1\) was
itself created through parallel composition, \(B_2\) will not begin until all chains
of execution of \(B_1\) are completed.

\begin{figure}
\begin{center}
\includegraphics[height=0.8in]{images/tikz/series.pdf}
\includegraphics[height=0.8in]{images/tikz/parallel.pdf} \vspace{0.in}
\includegraphics[height=0.8in]{images/tikz/parallel-and-series.pdf}
\end{center}
\caption{Series and parallel composition of behaviors }
\label{fig:graph-composition}
\end{figure}

\subsubsection*{Example}
Let's say we have the
car design shown in Figure X.  This design is composed of four wheel modules
and  a central steering element, which rotates to bend the front wheels to the
left or right relative the back, causing the car to turn.  The wheel elements
expose a function which turns the two side turntables in sync in order to drive
forward.  The steering element exposes a steering function.  We
show these behavior  definitions below:
\begin{align*}
%
\mathrm{DRV}(v,t) =~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\
Pc \left( \begin{array}{cccc}
(~lWheel, & \dot\theta=v, & \xi:0, & T:t~), \\
(~rWheel, & \dot\theta=v, & \xi:0, & T:t~) \\
\end{array} \right)\\
%
\mathrm{ST R}(x) = ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\ 
Pc \left( \begin{array}{cccc}
(~tTable1 & \theta=x, & \xi:[\theta=x], & T=\infty~), \\
(~tTable2 & \theta=-x, & \xi: [\theta=-x], & T=\infty~) \\
\end{array} \right)
%
\end{align*}

After composing these sub-configurations into the car, we build higher-level
behaviors by composing the behaviors of the sub-configurations.  We define functions
to go-straight (GST) and turn (TRN):
\begin{align*}
\mathrm{GST}(v,t) &= Pc (~\mathrm{STR}(0),~ \mathrm{DRV}(v,t)~)\\
\mathrm{TRN}(v,t,x) &= Pc (~\mathrm{STR}(x),~\mathrm{DRV}(v,t)~)
\end{align*}

We can now easily define trajectories by sequencing go-straight and turn commands
in series. Figure \ref{fig:zigzag} shows the path generated by the zig-zag behavior defined
below:

\begin{align*}
ZGZ = ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\
Sc(~\mathrm{GST}(10,5),~\mathrm{TRN}(10,5,30),~\mathrm{GST}(10,5),\\
~\mathrm{TRN}(10,10,-30),~\mathrm{GST}(10,20), \\
\mathrm{TRN}(10,10,30), \mathrm{GST}(10,5), \mathrm{TRN}(10,10, -30 )~)
\end{align*}

\begin{figure}
\begin{center}
\includegraphics[width=0.7\columnwidth]{images/zigzag.png}
\end{center}
\caption{Zig-zag trajectory \TODO{This is hand-drawn, sorry about that... I will
make a more professional-looking replacement}}
\label{fig:zigzag}
\end{figure}
 
\subsection{Controller Composition}
\TODO{Tarik and Jim write}
\paragraph{Input}
A configurations. A set of controllers. A control composition graph.
\paragraph{Output}
A composed controller if it is safe.
\paragraph{Procedure}
\begin{itemize}
\item Compose the set of controllers based on the given control composition graph. Explain how the parallel composition and series composition are handled.
\item\textbf{Check there is no controller conflict in the composition.}
\item Execute the composed controller in user defined incremental time interval. At each time step, update each module position and check collision.
\item \textbf{At each time step, check if the configuration will not have any unexpected behavior.}
\end{itemize}

\subsection{Simulation and Verification}
\TODO{Jim writes}

\subsection{Complexity}
Discuss the complexity of the algorithm with respect to the number of modules and size of gait tables.

\section{Example and Experiment}
\label{sec:example}
\TODO{Tarik and Jim write}\\
With simulation in Gazebo:
\begin{itemize}
\item Show a configuration composed from a set of basic configurations.
\item Show a composed controller that results in a collision in the configuration.
\item Show an updated controller that resolves the collision
\item Show a composed controller that results in an unexpected behavior.
\item Show an updated controller that eliminates the unexpected behavior.
\end{itemize}
\subsection{Comparison to Existing Methods}
\TODO{Tarik writes}\\
In the past, designing configurations and behaviors to address new tasks has required
time on the order of one day \cite{sastra2011using}. \TODO{compare to our results.}

\section{Conclusions}
We worked hard, and had fun.

\section{Future}
\begin{itemize}
\item How to represent different attribute/ability of the configurations
\end{itemize}




%% Use plainnat to work nicely with natbib. 

\bibliographystyle{plainnat}
\bibliography{references}

\end{document}
















